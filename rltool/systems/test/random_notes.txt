srew {startTest(2)} using (acceptedClient | allowActionNewURL | allowActionSwitchTab | change-display | checkWhitelist | closedSocket | closedSocketDuringTunnel | closedSocketDuringTunnelFinish | closeExternalSocket | closeLocalSocket | connectedToServer | connectToServer | createClient | createClientManager | createClientTcpSocketMsgExternalClient | createClientTcpSocketMsgLocalClient | createdSocket | createdUISocket | createServerTcpSocketMsg | createSocketManager | createSocksServer | createUI | fetch | finishedReadingHeader | kernelForwardsOPMessage | kernelReceivesOPMessage-pa1 | kernelReceivesOPMessage-pa10 | kernelReceivesOPMessage-pa2 | kernelReceivesOPMessage-pa3 | kernelReceivesOPMessage-pa4 | kernelReceivesOPMessage-pa5 | kernelReceivesOPMessage-pa6-a | kernelReceivesOPMessage-pa6-b | kernelReceivesOPMessage-pa7 | kernelReceivesOPMessage-pa8 | kernelReceivesOPMessage-pa9 | mem-in | mem-out | msg-to-kernel | newNetworkApp | newTabUI | new-url | nic1 | openTunnel | openTunnelFailure | openTunnelSuccess | proc-in | proc-out | readMethod | readPort | readRequest1 | readRequest2 | readRequestIPV4 | readRequestReply | readRequestSTR | receive | received | receivedFetchState | receivedNewURL | receivedSwitchTab | receiveExternalSocket | receiveHeader1 | receiveHeaderMethods | receiveLocalSocket | receiveLocalSocketNotExist | render | request-from-webapp | sendExternalSocket | sendHeader | sendLocalSocket | sendLocalSocketNotExist | sendRequest | sendWebsiteMsg | sent | shouldClose | startClient | startIBOS | startTest | switchTabUI | tab-change | tunnelClosed | tunnelingAckSend | tunnelingRecv | tunnelingSend | waitForGreeting | createdSocket2 | acceptedClient2 | receive2 | sent2 | a | b | c)* .

srew {startTest(2)} using (all)* .


First phase might be to do what we did in previous semester in a nicer / more complete way using strategy language. Have previous thing as a benchmark. Once done, can think about how to enrich in different directions. Theme could be low hanging fruit / big bang for buck. Something not too complicated and we could see something interesting with it. Browser security / crypto security / DOS security. Any of those could be interesting. Browser with stronger security properties than SOP. Many things possible. Figure out something we can break down.

Some secure communication between client / server or other scenarios. Imagine a DOS. Crypto costly to compute, so DOS can be more crippling. In this case a defense could buy a lot more than in a normal scenario. Simple checks are easy like cookie or something. The more computation the server has to do before knowing if it rejects or not the request the more damage the DOS can do to that server. Number of techniques exist to make sure we are an honest participant. Can force extra work or something else. A probabilistic technique made earlier. Crowded room need to talk to someone what to do? Shout at them. Timeout as a client where we expect to get an answer by some time. If haven't received send 2 messages, else send 4, ... exponentially. Fighting fire with fire, so what is server doing? Server can measure how busy it is, and as it gets busier it throws out without looking more and more requests probabilistically. More rejects when more junk exists. Will slow down communication but with high probability the honest clients will be heard. As attack gets bigger have to shout higher and takes longer for server to get request. Can also provision more servers. When the servers get certian level of business provision a new one (they are already throwing stuff out), do it in combination with this defense mechanism. Combination of these two can achieve stable availability. Communication is only slowed down by a constant factor, depending on when we decide to provision a new server. Good guys can still communicate, slowdown is a tradeoff.

Formal patterns are generic solutions to a problem that can be reused in many different settings, and come with some properties. Protocol and DOS protection are formal patterns. Client sends request to server and expects answer back. Some wrapper encrypts message and sends to wrapper around server to decrypt and pass to server. A modular way to insert the encryption in between a protocol. Instead of a monolithic system have a modular system. "Taming..." paper. Similar to breaking things down to services.


Figuring out how to write search as srew:
search start =>* X:State s.t. not I(X:State) .

could help:
srew (0)[nil] (1)[nil] (2)[3 2 1] using match (N)[3 2 1] H s.t. N =/= 0 .

try with toy example and make sure we get same number of states and results
not only commands it reaches but those that also pass this test

- Pair of state and continuation
- In the complicated case the continuation is also more complicated
- Search is keeping show graph thing too
- Computation involves computing the next state but also the continuation of the strategy
- Reaches same things but doing more work less work to do so
- Could try using the show command for a simpler example
- Pair of state and continuation strategy
- If we run into tricky questions can ask

- Only when we are considering all the rules that can use the all command, there is a trick we might consider:
  - Can give the same label to similar rules
  - Can have a much smaller
  - Labels can be repeated
  - Same label to all rules in one set of rules
  - Should save rewrites
  - Downside is will need to change labels a lot
  - Should see same states reached, but simpler computation on the strategy side

- Check timing between this version and the model checking we did last sem
- Model check with srew only as opposed to the search command for the equivalent command we would give, is there a difference in performance. May see lower performance for the search command. Stores whole graph for search but not for srew. Could have a simpler search that doesn't store continuations too. If search with strategy seems to be not efficient that would be good to know.



==========================ibos-socket.maude==================================

(fetch | render | request-from-webapp | proc-in | proc-out | nic1 | msg-to-kernel | mem-out | mem-in | kernelReceivesOPMessage-pa1 | kernelReceivesOPMessage-pa2 | kernelReceivesOPMessage-pa3 | kernelReceivesOPMessage-pa4 | kernelReceivesOPMessage-pa5 | kernelReceivesOPMessage-pa6-a | kernelReceivesOPMessage-pa6-b | kernelReceivesOPMessage-pa7 | kernelReceivesOPMessage-pa8 | kernelReceivesOPMessage-pa9 | kernelReceivesOPMessage-pa10 | kernelForwardsOPMessage | tab-change | change-display | new-url | startIBOS | newNetworkApp | createdSocket2 | receivedNewURL | receivedSwitchTab | receivedFetchState | received | sent3)

==========================socket_mock.maude==================================

(createSocketManager | createClientTcpSocketMsgLocalClient | createClientTcpSocketMsgExternalClient | createServerTcpSocketMsg | sendExternalSocket | receiveExternalSocket | sendLocalSocket | receiveLocalSocket | closeExternalSocket | closeLocalSocket | sendLocalSocketNotExist | receiveLocalSocketNotExist)

==========================socks.maude==================================

(createSocksServer | receive2 | sent2 | closedSocket | closedSocketDuringTunnel | closedSocketDuringTunnelFinish | shouldClose | createdSocket | acceptedClient2 | waitForGreeting | receiveHeader1 | receiveHeaderMethods | finishedReadingHeader | readRequest1 | readRequest2 | readRequestIPV4 | readRequestSTR | checkWhitelist | readPort | openTunnel | openTunnelFailure | openTunnelSuccess | tunnelingAckSend | tunnelingRecv | tunnelingSend | tunnelClosed)

==========================tests.maude==================================

(createClientManager | createClient | receive | sent | connectToServer | connectedToServer | sendHeader | readMethod | sendRequest | readRequestReply | sendWebsiteMsg | a | b | c | createUI | createdUISocket | acceptedClient | newTabUI | startClient | allowActionNewURL | switchTabUI | allowActionSwitchTab | startTest)


(A! ; B! ; C! ; D!)*

(A! | B! | C! | D!)*

Solution 149
rewrites: 8977 
Solution 149

Solution 149
rewrites: 8977 in 96ms cpu


9039 in 96ms
rewrites: 9039 in 356ms cpu


srew {startTest(2)} using ((testfile)! | (socksfile)! | (socketfile)! | (ibosfile)!)* .

srew {startTest(2)} using ((testfile)! ; (socksfile)! ; (socketfile)! ; (ibosfile)!)* .


- can say how many solutions we want using search
- search init =>! exp. s.t. C using strategy .
  - should give you solutions where the strategy cannot be continued
  - probably means terminating state
  - may not be what we want if searching for violation. predicated may be violated before termination

=>! will only show you states dealing with (state, continuation of strategy). will see what remains to be done of the strategy. a ; b ; c, then b ; c, then c, then nothing. bang will give state where continuation is idle. may use it for testing but dont want for finding invariants.

=>! normal search without strategy will find terminating states and then check whether the property is satisfied.
=>! with strategy will give states in which strategy has terminated. if give bang for a ; b ; c, then will be just terminating for the strategy so a applied b applied c applied, then strategy has terminated and it will show us that.

- search[1] syntax can show you first solution finds , if looking for violation one solution is enough

rewrites: 8977

srew {startTest(2)} using ((fetch | render | request-from-webapp | proc-in | proc-out | nic1 | msg-to-kernel | mem-out | mem-in | kernelReceivesOPMessage-pa1 | kernelReceivesOPMessage-pa2 | kernelReceivesOPMessage-pa3 | kernelReceivesOPMessage-pa4 | kernelReceivesOPMessage-pa5 | kernelReceivesOPMessage-pa6-a | kernelReceivesOPMessage-pa6-b | kernelReceivesOPMessage-pa7 | kernelReceivesOPMessage-pa8 | kernelReceivesOPMessage-pa9 | kernelReceivesOPMessage-pa10 | kernelForwardsOPMessage | tab-change | change-display | new-url | startIBOS | newNetworkApp | createdSocket2 | receivedNewURL | receivedSwitchTab | receivedFetchState | received | sent3)! | (createSocketManager | createClientTcpSocketMsgLocalClient | createClientTcpSocketMsgExternalClient | createServerTcpSocketMsg | sendExternalSocket | receiveExternalSocket | sendLocalSocket | receiveLocalSocket | closeExternalSocket | closeLocalSocket | sendLocalSocketNotExist | receiveLocalSocketNotExist)! | (socksfile)! | (createClientManager | createClient | receive | sent | connectToServer | connectedToServer | sendHeader | readMethod | sendRequest | readRequestReply | sendWebsiteMsg | a | b | c | createUI | createdUISocket | acceptedClient | newTabUI | startClient | allowActionNewURL | switchTabUI | allowActionSwitchTab | startTest)!)* .

srew {startTest(2)} using ((fetch | render | request-from-webapp | proc-in | proc-out | nic1 | msg-to-kernel | mem-out | mem-in | kernelReceivesOPMessage-pa1 | kernelReceivesOPMessage-pa2 | kernelReceivesOPMessage-pa3 | kernelReceivesOPMessage-pa4 | kernelReceivesOPMessage-pa5 | kernelReceivesOPMessage-pa6-a | kernelReceivesOPMessage-pa6-b | kernelReceivesOPMessage-pa7 | kernelReceivesOPMessage-pa8 | kernelReceivesOPMessage-pa9 | kernelReceivesOPMessage-pa10 | kernelForwardsOPMessage | tab-change | change-display | new-url | startIBOS | newNetworkApp | createdSocket2 | receivedNewURL | receivedSwitchTab | receivedFetchState | received | sent3)! ; idle | (createSocketManager | createClientTcpSocketMsgLocalClient | createClientTcpSocketMsgExternalClient | createServerTcpSocketMsg | sendExternalSocket | receiveExternalSocket | sendLocalSocket | receiveLocalSocket | closeExternalSocket | closeLocalSocket | sendLocalSocketNotExist | receiveLocalSocketNotExist)! ; idle | (createSocksServer | receive2 | sent2 | closedSocket | closedSocketDuringTunnel | closedSocketDuringTunnelFinish | shouldClose | createdSocket | acceptedClient2 | waitForGreeting | receiveHeader1 | receiveHeaderMethods | finishedReadingHeader | readRequest1 | readRequest2 | readRequestIPV4 | readRequestSTR | checkWhitelist | readPort | openTunnel | openTunnelFailure | openTunnelSuccess | tunnelingAckSend | tunnelingRecv | tunnelingSend | tunnelClosed)! ; idle | (createClientManager | createClient | receive | sent | connectToServer | connectedToServer | sendHeader | readMethod | sendRequest | readRequestReply | sendWebsiteMsg | a | b | c | createUI | createdUISocket | acceptedClient | newTabUI | startClient | allowActionNewURL | switchTabUI | allowActionSwitchTab | startTest)!)* .



srew {startTest(2)} using ((createClientManager | createClient | receive | sent | connectToServer | connectedToServer | sendHeader | readMethod | sendRequest | readRequestReply | sendWebsiteMsg | a | b | c | createUI | createdUISocket | acceptedClient | newTabUI | startClient | allowActionNewURL | switchTabUI | allowActionSwitchTab | startTest)! ; (fetch | render | request-from-webapp | proc-in | proc-out | nic1 | msg-to-kernel | mem-out | mem-in | kernelReceivesOPMessage-pa1 | kernelReceivesOPMessage-pa2 | kernelReceivesOPMessage-pa3 | kernelReceivesOPMessage-pa4 | kernelReceivesOPMessage-pa5 | kernelReceivesOPMessage-pa6-a | kernelReceivesOPMessage-pa6-b | kernelReceivesOPMessage-pa7 | kernelReceivesOPMessage-pa8 | kernelReceivesOPMessage-pa9 | kernelReceivesOPMessage-pa10 | kernelForwardsOPMessage | tab-change | change-display | new-url | startIBOS | newNetworkApp | createdSocket2 | receivedNewURL | receivedSwitchTab | receivedFetchState | received | sent3)! ; (createSocketManager | createClientTcpSocketMsgLocalClient | createClientTcpSocketMsgExternalClient | createServerTcpSocketMsg | sendExternalSocket | receiveExternalSocket | sendLocalSocket | receiveLocalSocket | closeExternalSocket | closeLocalSocket | sendLocalSocketNotExist | receiveLocalSocketNotExist)! ; (createSocksServer | receive2 | sent2 | closedSocket | closedSocketDuringTunnel | closedSocketDuringTunnelFinish | shouldClose | createdSocket | acceptedClient2 | waitForGreeting | receiveHeader1 | receiveHeaderMethods | finishedReadingHeader | readRequest1 | readRequest2 | readRequestIPV4 | readRequestSTR | checkWhitelist | readPort | openTunnel | openTunnelFailure | openTunnelSuccess | tunnelingAckSend | tunnelingRecv | tunnelingSend | tunnelClosed)!)* .


TODO:
- Figure out why changing order from ABCD to DABC made the example continue
      -> Not sure yet
- May have to do with the bang operator going to the end of the process, order could matter here
- How does it compare to what we did can we find the same bugs using this?
- Interesting if this is doing same thing as tweaked model checking version, check frontier of states in one case and the other or if its not the same
- Build intuition on strategy language specs






((testfile)! ; (socksfile)! ; (socketfile)! ; (ibosfile)!)!
(to termination any file)!

A! => (A)* ; not(A)
A!! => A!* ; not(A!)
not(A!) => not((A)* ; not(A)) => not(not(A)) => A

A!! => A!* ; A => (A* ; not(A))* ; A



A! => A* ; not(A)
A!! => (A!)* ; not(A!)


run (to termination any file) until not(to termination any file)



srew {startTest(2)} using ((testfile)! ; (socksfile)! ; (socketfile)! ; (ibosfile)!)* ; not(testfile) ; not(socksfile) ; not(socketfile) ; not(ibosfile) .

- TODO check if theres AND for this not ; not ; not ; not

- take a look at how socket was done in the other paper
- want sockets to be a faithful abstraction of what actually happens (second look at how socket external objects are described in the book / manual and the paper) so that our mimicking really reflects directly what is happening. if there is distance between the two may experience problems that are not really problems.


{ Config Config }

Bug we found

rl [testfile] :
  { startTest(N) }
=>
  {
    <>
    startIBOS
    inspect(N)
  }
  .

crl [socketfile] :
  { Config }
=>
  { < socketManager : SocketManager | 
    nextNumber: 0, 
    connections: mtCS,
    localServers: mtLSS >
    Config
  }
if
  not socketManagerInConfig(Config)
  .










Bug we found
**** no policy allowed this, therefore implicitly disallowed and dropped
rl [ibosfile] :
   { < kernel | handledCurrently(none), msgPolicy(MP),  Att  >
     < PPI1   | toKernel(msg(ORG, GPPI, MT, L) @ ML),   Att2 > Cnf }
=>
   { < kernel | handledCurrently(none), msgPolicy(MP), Att  >
     < PPI1   | toKernel(ML),                          Att2 > Cnf } .


- can send this to skeirik and carbon copy
- fewer behaviors usually doesnt cause problems, but more behaviors does.
- this model has a bug, skeirik should know, think about how to correct the rule or he can also figure it out



search {startTest(4)} =>* (X:State) s.t. not IABC(X:State) using ((havoc) | ((testfile)! ; (socksfile)! ; (socketfile)! ; (ibosfile)!))* ; not(testfile) ; not(socksfile) ; not(socketfile) ; not(ibosfile) .













srew {startTest(2)} using ((testfile)! ; (socksfile)! ; (socketfile)! ; (ibosfile)!)* ; not(testfile) ; not(socksfile) ; not(socketfile) ; not(ibosfile) ; match (X:State) s.t. not IABC(X:State) .

- searching and testing, strategy as a whole terminates when the test is satisfied, doesnt mean it cannot continue.
- in the srew, if rewrite it to termination then it will give us all the states that have fully evaluated the strategy. if want to show only when S.T. condition holds, doing these tests and if it holds then thats the result of the strategy.




search {startTest(8)} =>* (X:State) s.t. not IABC(X:State) using ((testfile)! ; (socksfile)! ; (socketfile)! ; (ibosfile)!)* ; not(testfile) ; not(socksfile) ; not(socketfile) ; not(ibosfile) .
search {startTest(8)} =>* (X:State) s.t. not IABC(X:State) .

Debug(2)> search {startTest(8)} =>* (X:State) s.t. not IABC(X:State) .
search in TEST : {startTest(8)} =>* X:State such that not IABC(X:State) = true .

No solution.
states: 19733  rewrites: 1932738 in 7268ms cpu (7306ms real) (265924 rewrites/second)
Debug(2)> search {startTest(8)} =>* (X:State) s.t. not IABC(X:State) using ((testfile)! ; (socksfile)! ; (socketfile)! ; (ibosfile)!)* ; not(testfile) ; not(socksfile) ; not(socketfile) ; not(ibosfile) .
search in TEST : {startTest(8)} =>* X:State such that not IABC(X:State) = true using (testfile ! ; socksfile ! ; socketfile ! ; ibosfile !)* ; not(testfile) ; not(socksfile) ; not(socketfile) ; not(ibosfile) .


No solution.
states: 12570  rewrites: 691335 in 3636ms cpu (3633ms real) (190136 rewrites/second)
Debug(2)> 







CRASH:
Maude internal error.
Please submit a bug report to: maude-bugs@lists.cs.illinois.edu
Please include the platform details, Maude version, and a file
`crash.maude' that can be loaded to reproduce the crash (it may load
other files). Do not bother trying to simplify your example unless the
runtime to the bug being visible is greater than 10 seconds.

search {startTest(5)} =>* (X:State) s.t. not IABC(X:State) using ((havoc) | ((testfile)! ; (socksfile)! ; (socketfile)! ; (ibosfile)!))* ; not(testfile) ; not(socksfile) ; not(socketfile) ; not(ibosfile) .



- important thing is to make sure its reproducible. if can send something smaller then easier. shouldn't spend a huge amount of time on that. if with not much effort we can simplify then worth it.
- Some high level explanation of what is going on - what its trying to do and what went wrong.
- he would probably more interested in how the strategies are being evaluated to find the bug.
- notify, he can probably give us better version which fixes
- possible its a maude bug


- here is search command, here is way we wrote strategy to mimic search using srew, and he can check if its faithful.






- Figure out why havoc! doesnt work in above command depth 4

- Try to split test rules into two




-Trying to extend security properties of client <-> server
  - download page -> retreicive other resources -> make more requests -> only whitelisted ones work (and also for uploading data)
  - verifies proxy correctness

- May be related to formal patterns paper:
  - the properties are about security of communication
  - some enforceable by kernel, some enforceable by other component like proxy
  - these things can be modular

- want to think about code as modular instead of mixed together
- could modify client/server to do crypto. smart way is to create metaobjects between client and server, which wrap object and server. the code remains the same but the wrapper intercepts and encrypts.
- attacker that wants to read content of message can be done in previous situation
- with this protection now cannot do it
- also have a model of an attacker
- two systems do the same thing, but this one now protects against a hostile environment in which you have to live. can be for cryptography or another exampe is fault tolerance
- for fault tolerance attacker is rules that drop messages, to cope with that add meta objects that send acknowledgements, keep counts, resending stuff, that the original system didnt do.

- suggestion to think about these things since we're exploring different possibilities and security properties. Should explore it in a modular way. What are the meta objects that solve a problem. Take a look at "Formal patterns" paper.
- will help architecture
- each meta object comes with guarantees. if use enc, maicious cannot work. same idea with DOS attacks. original system doesnt know anything about this stuff but can now live in a malicious environment.
- may also make the verification more modular
- next time talk about issue of proxy, security policy for that, our thoughts for how this could be modeled or understood as a pattern or metaobject or something like that
- inform everyone ^ about issues


