load state.maude
load network.maude
load time.maude
load file.maude

mod SAMPLER is
pr RANDOM .
pr COUNTER .
pr CONVERSION .
op rand : -> [Float] .
op sampleBernoulli : Float -> [Bool] .
rl rand => float(random(counter) / 4294967295) .
rl sampleBernoulli(P:Float) => rand < P:Float .

op sampleUniform : Int Int -> [Int] .
vars MAX MIN : Int .
rl sampleUniform(MIN, MAX) => rat(floor(rand * float((MAX - MIN) + 1))) + MIN .
endm

mod ASV_WRAPPER_COMMON is 
pr NETWORK .
pr STATE .
pr SAMPLER .
pr TIME .
pr STD-STREAM .

op clientASVWrapper : Oid -> Oid .
op ClientASVWrapper : -> Cid .

op serverASVWrapper : Oid -> Oid .
op ServerASVWrapper : -> Cid .
endm

mod CLIENT_ASV_WRAPPER is
pr ASV_WRAPPER_COMMON .

vars A B O D : Oid .
vars M : MessageContent .
vars C C' : Configuration .
vars N : Nat .
vars Att Att' Att'' : AttributeSet .
vars ST : State .

vars MSG : Msg .

sort CAWState .
ops waiting startSend sending sendingWaitTimer sent : -> CAWState [ctor] .

op cawState:_ : CAWState -> Attribute [ctor] .
op currentMsg:_ : Msg -> Attribute [ctor] .
op numToSend:_ : Nat -> Attribute [ctor] .
op timer:_ : Oid -> Attribute [ctor] .

op noTimer : -> Oid [ctor] .
op noMsg : -> Msg [ctor] .

op repeat : Msg Nat -> Configuration .
crl repeat(MSG, N) => MSG repeat(MSG, N - 1) if N =/= 0 .
crl repeat(MSG, N) => none if N == 0 .

op createClientASVWrapper : Oid State -> Configuration [ctor] .
eq createClientASVWrapper(A, ST) = 
  < clientASVWrapper(A) : ClientASVWrapper | cawState: waiting, currentMsg: noMsg, world: ST, numToSend: 1, timer: noTimer >
  .

rl [outgoingMsg] :
  < clientASVWrapper(A) : ClientASVWrapper | cawState: waiting, currentMsg: noMsg, world: {
    (msg M from A to B)
    C
  }, Att >
=>
  < clientASVWrapper(A) : ClientASVWrapper | cawState: startSend, currentMsg: (msg M from clientASVWrapper(A) to serverASVWrapper(B)), world: {
    C
  }, Att >
  .

rl [startSend] :
  < clientASVWrapper(A) : ClientASVWrapper | cawState: startSend, Att >
=>
  createTimer(timeManager, clientASVWrapper(A))
  < clientASVWrapper(A) : ClientASVWrapper | cawState: sendingWaitTimer, Att >
  .

rl [createdTimer] :
  createdTimer(clientASVWrapper(A), B, O)
  < clientASVWrapper(A) : ClientASVWrapper | cawState: sendingWaitTimer, timer: D, Att >
=>
  < clientASVWrapper(A) : ClientASVWrapper | cawState: sending, timer: O, Att >
  .

rl [sending] :
  < clientASVWrapper(A) : ClientASVWrapper | cawState: sending, currentMsg: MSG, numToSend: N, timer: O, Att >
=>
  repeat(MSG, N)
  startTimer(O, clientASVWrapper(A), oneShot, 1 seconds)
  < clientASVWrapper(A) : ClientASVWrapper | cawState: sent, currentMsg: MSG, numToSend: N, timer: O, Att >
  .

rl [incomingMsg] :
  < clientASVWrapper(B) : ClientASVWrapper | cawState: sent, currentMsg: MSG, numToSend: N, timer: O, world: {
    C
  }, Att >
  (msg M from serverASVWrapper(A) to clientASVWrapper(B))
=>
  stopTimer(O, clientASVWrapper(A))
  < clientASVWrapper(B) : ClientASVWrapper | cawState: waiting, currentMsg: noMsg, numToSend: 1, timer: noTimer, world: {
    (msg M from A to B)
    C
  }, Att >
  .

rl [timeoutTimer] :
  < clientASVWrapper(A) : ClientASVWrapper | cawState: sent, timer: O, numToSend: N, Att >
  timeOut(clientASVWrapper(A), O)
=>
  deleteTimer(O, clientASVWrapper(A))
  < clientASVWrapper(A) : ClientASVWrapper | cawState: startSend, timer: noTimer, numToSend: (N * 2), Att >
  .


rl [startedTimer] :
  startedTimer(clientASVWrapper(A), O)
=>
  none
  .

rl [stoppedTimer] :
  stoppedTimer(O, clientASVWrapper(A))
=>
  deleteTimer(O, clientASVWrapper(A))
  .

rl [deletedTimer] :
  deletedTimer(clientASVWrapper(A), O)
=>
  none
  .

endm

mod SERVER_ASV_WRAPPER is
pr ASV_WRAPPER_COMMON .

vars A B O : Oid .
vars M : MessageContent .
vars C C' : Configuration .
vars Att Att' Att'' : AttributeSet .
vars Buff : Buffer .
vars N N' : Nat .
vars CT : Nat .

op ctr:_ : Nat -> Attribute .

op log : Universal -> Configuration [ctor poly(1)] .

crl [incomingMsgNotFull] :
  < serverASVWrapper(B) : ServerASVWrapper | msgBuffer: Buff, bufferLen: N, maxBufferLen: N', Att >
  (msg M from clientASVWrapper(A) to serverASVWrapper(B))
=>
  < serverASVWrapper(B) : ServerASVWrapper | msgBuffer: (Buff, (msg M from A to B)), bufferLen: s(N), maxBufferLen: N', Att >
if
  N < N'
  .

crl [incomingMsgFull] :
  < serverASVWrapper(B) : ServerASVWrapper | msgBuffer: Buff, bufferLen: N, maxBufferLen: N', ctr: CT, Att >
  (msg M from clientASVWrapper(A) to serverASVWrapper(B))
=>
  ---write(stdout, A, "Full\n")
  ---log((msg string(CT, 10) from A to B), Buff)
  if sampleBernoulli(float(N') / (float(CT) + 1.0))
  then < serverASVWrapper(B) : ServerASVWrapper | msgBuffer: replace(Buff, (msg M from A to B), sampleUniform(0, N' - 1)), 
         bufferLen: N, maxBufferLen: N', ctr: (CT + 1), Att >
  else < serverASVWrapper(B) : ServerASVWrapper | msgBuffer: Buff, bufferLen: N, maxBufferLen: N', ctr: (CT + 1), Att >
  fi
if 
  N == N'
  .

crl [passBuffer] :
  < serverASVWrapper(B) : ServerASVWrapper | msgBuffer: Buff, bufferLen: N, ctr: CT, world: { 
    < B : Server | msgBuffer: mtB, bufferLen: 0, Att' >
    C 
  }, Att >
=>
  write(stdout, B, "Passed buffer down\n")
  < serverASVWrapper(B) : ServerASVWrapper | msgBuffer: mtB, bufferLen: 0, ctr: 0, world: { 
    < B : Server | msgBuffer: Buff, bufferLen: N, Att' >
    C 
  }, Att >
if
  N =/= 0
  .

rl [outgoingMsg] :
  < serverASVWrapper(A) : ServerASVWrapper | world: {
    (msg M from A to B)
    C
  }, Att >
=>
  < serverASVWrapper(A) : ServerASVWrapper | world: {
    C
  }, Att >
  (msg M from serverASVWrapper(A) to clientASVWrapper(B))
  .

op isWrapped : Oid -> Bool .
eq isWrapped(clientASVWrapper(A)) = true .
eq isWrapped(A) = false [owise] .

--- When using sockets, incoming messages don't know the wrapper structure (since we don't encode message contents yet)
--- This allows a msg without the clientASVWrapper(...) oid to be accepted
crl [rewriteUnwrapped] :
  (msg M from A to serverASVWrapper(B))
=>
  (msg M from clientASVWrapper(A) to serverASVWrapper(B))
if
  not isWrapped(A)
  .

endm