load state.maude
load network.maude
load tls_data.maude

--- Implements TLS wrapper using the TLS module
--- See blank_wrapper.maude for more detailed comments
mod TLS_WRAPPER is
pr NETWORK .
pr STATE .
pr TLS .

op tlsWrapper : Oid -> Oid .
op TLSWrapper : -> Cid .

--- Contained client/server
op world:_ : State -> Attribute .

--- Do we trust the connection yet?
op trusted:_ : Bool -> Attribute .

--- Who are we connected to?
op connected:_ : Oid -> Attribute .

vars A B O : Oid .
vars M : MessageContent .
vars C C' : Configuration .
vars Att Att' Att'' Att''' : AttributeSet .

op _in_ : Configuration Configuration -> Bool .
eq C in (C C') = true .
eq C in C' = false [owise] .

vars IS : InitSessions .
vars RS : RespSessions .

vars K K' : Payload .
vars T : Payload .
vars Nonce : Nonce .

--- When initiating, also create an Agent
--- The two agents will authenticate, and then give us the go-ahead to use them to send more data
crl [clientInitiate] : {
  < tlsWrapper(A) : TLSWrapper | world: {
    (open A to B)
    C
  }, Att >
  C'
}
=> {
  < tlsWrapper(A) : TLSWrapper | world: {
    (open A to B)
    C
  }, Att >
  (open tlsWrapper(A) to tlsWrapper(B))
  < tlsWrapper(A) : Agent | nextNonce: 0, initSessions: notInitiated(tlsWrapper(B)), respSessions: emptySession >
  C'
}
if
  not (open tlsWrapper(A) to tlsWrapper(B)) in C'
  .

--- This creates the other agent
crl [wrapperInitiate] :
  < tlsWrapper(B) : TLSWrapper | world: {
    C
  }, Att >
  (open tlsWrapper(A) to tlsWrapper(B))
=>
  < tlsWrapper(B) : TLSWrapper | world: {
    C
    (open A to B)
  }, Att >
  (open tlsWrapper(A) to tlsWrapper(B))
  < tlsWrapper(B) : Agent | nextNonce: 0, initSessions: emptySession, respSessions: emptySession >
if
  not (open A to B) in C
  .

--- Once agent has trusted the other, we can mark it down and allow sending messages
rl [agentsConnected] :
  < tlsWrapper(A) : Agent | initSessions: ((trusted: tlsWrapper(B) k1: K k2: K' nonce: Nonce) IS), Att >
  < tlsWrapper(A) : TLSWrapper | trusted: false, Att'' >
=>
  < tlsWrapper(A) : Agent | initSessions: ((trusted: tlsWrapper(B) k1: K k2: K' nonce: Nonce) IS), Att >
  < tlsWrapper(A) : TLSWrapper | trusted: true, connected: B, Att'' >
  .

--- Need to do this for both agents
rl [agentsConnected] :
  < tlsWrapper(B) : Agent | respSessions: ((trusted: tlsWrapper(A) k1: K k2: K' nonce: Nonce) RS), Att' >
  < tlsWrapper(B) : TLSWrapper | trusted: false, Att''' >
=>
  < tlsWrapper(B) : Agent | respSessions: ((trusted: tlsWrapper(A) k1: K k2: K' nonce: Nonce) RS), Att' >
  < tlsWrapper(B) : TLSWrapper | trusted: true, connected: A, Att''' >
  .

--- An outgoing message is converted into TLSsend
crl [outgoingMsg] :
  < tlsWrapper(A) : TLSWrapper | connected: B, world: {
    (msg M from A to B)
    C
  }, Att >
=>
  < tlsWrapper(A) : TLSWrapper | connected: B, world: {
    C
  }, Att >
  (TLSsend tlsWrapper(A) msg M)
if
  (open A to B) in C or (open B to A) in C
  .

--- A TLSrecv is converted to incoming message
crl [incomingMsg] :
  < tlsWrapper(B) : TLSWrapper | connected: A, world: {
    C
  }, Att >
  (TLSrecv tlsWrapper(B) msg M)
=>
  < tlsWrapper(B) : TLSWrapper | connected: A, world: {
    (msg M from A to B)
    C
  }, Att >
if
  (open A to B) in C or (open B to A) in C
  .

--- TODO: closing
endm