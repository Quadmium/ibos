load state.maude
load network.maude

mod BLANK_WRAPPER is
pr NETWORK .
pr STATE .

op blankWrapper : Oid -> Oid .
op BlankWrapper : -> Cid .

op world:_ : State -> Attribute .

vars A B O : Oid .
vars M : MessageContent .
vars C C' : Configuration .
vars Att Att' Att'' : AttributeSet .

op _in_ : Configuration Configuration -> Bool .
eq C in (C C') = true .
eq C in C' = false [owise] .

crl [clientInitiate] :
  < blankWrapper(A) : BlankWrapper | world: {
    (open A to B)
    C
  }, Att >
  < blankWrapper(B) : BlankWrapper | world: {
    C'
  }, Att' >
=>
  < blankWrapper(A) : BlankWrapper | world: {
    (open A to B)
    C
  }, Att >
  < blankWrapper(B) : BlankWrapper | world: {
    (open A to B)
    C'
  }, Att' >
if
  not (open A to B) in C'
  .

rl [clientMsg] :
  < blankWrapper(A) : BlankWrapper | world: {
    (open A to B)
    (msg M from A to B)
    C
  }, Att >
  < blankWrapper(B) : BlankWrapper | world: {
    (open A to B)
    C'
  }, Att' >
=>
  < blankWrapper(A) : BlankWrapper | world: {
    (open A to B)
    C
  }, Att >
  < blankWrapper(B) : BlankWrapper | world: {
    (open A to B)
    (msg M from A to B)
    C'
  }, Att' >
  .

rl [serverMsg] :
  < blankWrapper(A) : BlankWrapper | world: {
    (open A to B)
    C
  }, Att >
  < blankWrapper(B) : BlankWrapper | world: {
    (open A to B)
    (msg M from B to A)
    C'
  }, Att' >
=>
  < blankWrapper(A) : BlankWrapper | world: {
    (open A to B)
    (msg M from B to A)
    C
  }, Att >
  < blankWrapper(B) : BlankWrapper | world: {
    (open A to B)
    C'
  }, Att' >
  .

--- For this to work, a strategy needs to rewrite wrappers in order (so a close can be duplicated before it's consumed)
crl [close] :
  < blankWrapper(A) : BlankWrapper | world: {
    (open A to B)
    (close A to B)
    C
  }, Att >
  < blankWrapper(B) : BlankWrapper | world: {
    (open A to B)
    C'
  }, Att' >
=>
  < blankWrapper(A) : BlankWrapper | world: {
    (open A to B)
    (close A to B)
    C
  }, Att >
  < blankWrapper(B) : BlankWrapper | world: {
    (open A to B)
    (close A to B)
    C'
  }, Att' >
if
  not (close A to B) in C'
  .

endm