load state.maude
load network.maude

mod BLANK_WRAPPER is
pr NETWORK .
pr STATE .

op blankWrapper : -> Oid .
op BlankWrapper : -> Cid .

op clientWorld:_ : State -> Attribute .
op serverWorld:_ : State -> Attribute .

vars A B O : Oid .
vars M : MessageContent .
vars C C' : Configuration .
vars Att Att' Att'' : AttributeSet .

op _in_ : Configuration Configuration -> Bool .
eq C in (C C') = true .
eq C in C' = false [owise] .

crl [clientInitiate] :
  < O : BlankWrapper | clientWorld: {
    (open A to B)
    C
  }, serverWorld: { 
    C' 
  }, Att >
=>
  < O : BlankWrapper | clientWorld: {
    (open A to B)
    C
  }, serverWorld: { 
    (open A to B)
    C' 
  }, Att >
if
  not (open A to B) in C'
  .

rl [clientMsg] :
  < O : BlankWrapper | clientWorld: {
    (open A to B)
    (msg M from A to B)
    C
  }, serverWorld: { 
    (open A to B)
    C' 
  }, Att >
=>
  < O : BlankWrapper | clientWorld: {
    (open A to B)
    C
  }, serverWorld: { 
    (open A to B)
    (msg M from A to B)
    C' 
  }, Att >
  .

rl [serverMsg] :
  < O : BlankWrapper | clientWorld: {
    (open A to B)
    C
  }, serverWorld: { 
    (open A to B)
    (msg M from B to A)
    C' 
  }, Att >
=>
  < O : BlankWrapper | clientWorld: {
    (open A to B)
    (msg M from B to A)
    C
  }, serverWorld: { 
    (open A to B)
    C' 
  }, Att >
  .

--- For this to work, a strategy needs to rewrite wrappers in order (so a close can be duplicated before it's consumed)
crl [close] :
  < O : BlankWrapper | clientWorld: {
    (open A to B)
    (close A to B)
    C
  }, serverWorld: { 
    (open A to B)
    C' 
  }, Att >
=>
  < O : BlankWrapper | clientWorld: {
    (open A to B)
    (close A to B)
    C
  }, serverWorld: { 
    (open A to B)
    (close A to B)
    C' 
  }, Att >
if
  not (close A to B) in C'
  . 

endm